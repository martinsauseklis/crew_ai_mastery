"""
Extract platform code from markdown files and create runnable file structure.

This script reads the implementation markdown files generated by the demo and
extracts all code blocks, creating a proper directory structure with actual
runnable code files.
"""

import re
from pathlib import Path
from typing import List, Tuple
from rich.console import Console

console = Console()


def extract_code_blocks(markdown_path: Path) -> List[Tuple[str, str, str]]:
    """
    Extract code blocks from a markdown file.

    Returns:
        List of tuples: (filename, language, code_content)
    """
    if not markdown_path.exists():
        console.print(f"[yellow]Warning: {markdown_path} not found[/yellow]")
        return []

    content = markdown_path.read_text(encoding='utf-8')
    code_blocks = []

    # Find all ## headings and their positions (NOT inside code blocks)
    # Strategy: track code block boundaries and skip headings inside them
    heading_pattern = re.compile(r'^## (.+)$', re.MULTILINE)
    code_block_pattern = re.compile(r'^```', re.MULTILINE)

    # Find all potential section headings
    potential_headings = [(m.start(), m.end(), m.group(1)) for m in heading_pattern.finditer(content)]

    # Find all code block boundaries (opening and closing ```)
    code_boundaries = [m.start() for m in code_block_pattern.finditer(content)]

    # Determine which headings are outside code blocks
    valid_headings = []
    for start, end, title in potential_headings:
        # Count how many code block boundaries come before this heading
        boundaries_before = sum(1 for b in code_boundaries if b < start)
        # If even number, we're outside code blocks; if odd, we're inside
        if boundaries_before % 2 == 0:
            valid_headings.append((start, end, title))

    # Extract content for each valid heading
    for i, (heading_start, heading_end, heading_title) in enumerate(valid_headings):
        # Determine where this section ends (start of next heading or end of file)
        if i + 1 < len(valid_headings):
            section_end = valid_headings[i + 1][0]
        else:
            section_end = len(content)

        section_content = content[heading_end:section_end]

        # Find the first code block in this section
        first_backtick_match = re.search(r'^```(\w+)\s*$', section_content, re.MULTILINE)
        if not first_backtick_match:
            continue

        language = first_backtick_match.group(1)
        code_start = first_backtick_match.end()

        # Find the closing ``` for this code block
        # Look for the next ``` after the opening
        remaining_content = section_content[code_start:]
        closing_match = re.search(r'^```\s*$', remaining_content, re.MULTILINE)

        if not closing_match:
            # No closing backtick, take rest of section
            code = remaining_content.strip()
        else:
            # Extract content between opening and closing
            code = remaining_content[:closing_match.start()].rstrip()

        if heading_title and code:
            code_blocks.append((heading_title, language, code))

    # Normalize filenames from headings
    normalized_blocks = []
    for filename, language, code in code_blocks:
        normalized_filename = normalize_filename(filename)
        if normalized_filename:
            normalized_blocks.append((normalized_filename, language, code))

    return normalized_blocks


def normalize_filename(filename: str) -> str:
    """
    Normalize a filename from heading text to actual file path.

    Args:
        filename: Raw filename from markdown heading

    Returns:
        Normalized filename or empty string if invalid
    """
    original_filename = filename.strip()
    filename_lower = filename.strip().lower()

    # Mapping for common section names to actual filenames
    section_to_filename = {
        'docker-compose.yml': 'docker-compose.yml',
        'docker compose': 'docker-compose.yml',
        'backend dockerfile': 'backend/Dockerfile',
        'frontend dockerfile': 'frontend/Dockerfile',
        'dockerfile (backend)': 'backend/Dockerfile',
        'dockerfile (frontend)': 'frontend/Dockerfile',
        'backend/dockerfile': 'backend/Dockerfile',
        'frontend/dockerfile': 'frontend/Dockerfile',
        '.env.example': '.env.example',
        'env.example': '.env.example',
        'environment variables': '.env.example',
        'setup.sh': 'setup.sh',
        'setup script': 'setup.sh',
        'readme.md': 'README.md',
        'readme': 'README.md',
        'app.py': 'backend/app.py',
        'main.py': 'backend/main.py',
        'models.py': 'backend/models.py',
        'auth.py': 'backend/auth.py',
        'config.py': 'backend/config.py',
        'database.py': 'backend/database.py',
        'requirements.txt': 'backend/requirements.txt',
        'package.json': 'frontend/package.json',
    }

    # Direct match
    if filename_lower in section_to_filename:
        return section_to_filename[filename_lower]

    # Check if any path separators in filename
    if '/' in original_filename or '\\' in original_filename:
        # Already a path, normalize it
        normalized = original_filename.replace('\\', '/')
        # Fix common issues
        if normalized.lower().endswith('/dockerfile'):
            # backend/dockerfile -> backend/Dockerfile
            parts = normalized.rsplit('/', 1)
            return parts[0] + '/Dockerfile'
        return normalized

    # Remove any "## " prefix that might be in the heading
    if original_filename.startswith('## '):
        original_filename = original_filename[3:]
        filename_lower = original_filename.lower()

    # Check for pages/ or components/ prefixes (frontend files)
    if filename_lower.startswith(('pages/', 'components/', 'lib/', 'styles/')):
        return f"frontend/{original_filename}"

    # Try to find file extension
    file_pattern = r'([a-zA-Z0-9_./\-]+\.(py|js|jsx|ts|tsx|json|yml|yaml|sh|md|env|txt|html|css))'
    file_match = re.search(file_pattern, filename_lower, re.IGNORECASE)
    if file_match:
        found_file = file_match.group(1)
        # Check if it's in our mapping
        if found_file.lower() in section_to_filename:
            return section_to_filename[found_file.lower()]
        # Preserve original case for the actual filename part
        return found_file

    return ""


def write_code_file(base_dir: Path, filepath: str, content: str):
    """
    Write a code file to disk, creating directories as needed.

    Args:
        base_dir: Base directory for the platform code
        filepath: Relative file path (e.g., "backend/app.py")
        content: File content
    """
    full_path = base_dir / filepath
    full_path.parent.mkdir(parents=True, exist_ok=True)

    # Write file
    full_path.write_text(content, encoding='utf-8')
    console.print(f"  [green]OK[/green] Created: {filepath}")


def extract_and_build_platform(demo_artifacts_dir: Path, output_dir: Path):
    """
    Extract code from all implementation markdown files and build the platform.

    Args:
        demo_artifacts_dir: Directory containing demo artifacts
        output_dir: Output directory for platform code
    """
    console.print()
    console.print("[bold cyan]Extracting Platform Code[/bold cyan]")
    console.print()

    # Files to process
    markdown_files = {
        'backend_implementation.md': 'backend',
        'frontend_implementation.md': 'frontend',
        'deployment_setup.md': '.',  # Root level files
    }

    output_dir.mkdir(parents=True, exist_ok=True)
    total_files = 0

    for md_filename, default_subdir in markdown_files.items():
        md_path = demo_artifacts_dir / md_filename

        if not md_path.exists():
            console.print(f"[yellow]âš  Skipping {md_filename} (not found)[/yellow]")
            continue

        console.print(f"[bold]Processing {md_filename}...[/bold]")

        code_blocks = extract_code_blocks(md_path)

        if not code_blocks:
            console.print(f"  [yellow]No code blocks found[/yellow]")
            continue

        for filename, language, code in code_blocks:
            # Determine where to write the file
            # If filename starts with backend/ or frontend/, use as-is
            # Otherwise, prepend the default subdirectory
            if filename.startswith(('backend/', 'frontend/', './', '../')):
                filepath = filename
            elif filename in ['docker-compose.yml', '.env.example', 'setup.sh', 'README.md']:
                filepath = filename  # Root level files
            elif 'backend' in default_subdir and not filename.startswith('frontend'):
                filepath = f"backend/{filename}"
            elif 'frontend' in default_subdir and not filename.startswith('backend'):
                filepath = f"frontend/{filename}"
            else:
                filepath = f"{default_subdir}/{filename}"

            # Clean up path
            filepath = filepath.replace('//', '/').lstrip('./')

            try:
                write_code_file(output_dir, filepath, code)
                total_files += 1
            except Exception as e:
                console.print(f"  [red]FAIL Failed to write {filepath}: {e}[/red]")

    console.print()
    console.print(f"[bold green]SUCCESS: Platform code extracted successfully![/bold green]")
    console.print(f"[dim]Created {total_files} files in {output_dir}[/dim]")
    console.print()
    console.print("[bold]Next steps:[/bold]")
    console.print(f"  1. cd {output_dir}")
    console.print("  2. Review the generated code")
    console.print("  3. Follow instructions in README.md or deployment_setup.md")
    console.print()


def main():
    """Main entry point."""
    import sys

    # Add parent directory to path for imports
    script_dir = Path(__file__).parent.parent
    if str(script_dir) not in sys.path:
        sys.path.insert(0, str(script_dir))

    from demo_config import DemoConfig

    demo_artifacts_dir = DemoConfig.get_demo_artifacts_dir()
    platform_code_dir = demo_artifacts_dir / "platform_code"

    try:
        extract_and_build_platform(demo_artifacts_dir, platform_code_dir)
    except Exception as e:
        console.print(f"[red]Error: {e}[/red]")
        import traceback
        console.print(traceback.format_exc())
        return 1

    return 0


if __name__ == "__main__":
    import sys
    sys.exit(main())
